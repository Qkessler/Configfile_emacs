* Themes
** Subatomic theme.
#+BEGIN_SRC emacs-lisp
(use-package subatomic-theme
  :ensure t)
#+END_SRC

** Gruvbox theme.
#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :ensure t
  :config (load-theme 'gruvbox-dark-soft t))
#+END_SRC

** Sublime-themes.
#+BEGIN_SRC emacs-lisp
(use-package sublime-themes
  :ensure t)
#+END_SRC

** Monokai-theme
#+BEGIN_SRC emacs-lisp
(use-package monokai-theme
  :ensure t)
#+END_SRC

* Better defaults
** Keep emacs clean
This is the section created with the intention of make emacs create the files needed, but keep
the directories clean, saving the backup files in set locations.

*** No-littering
No littering is a package which is used with intention of keeping the generated
files by emacs to a minimum, by changing the path where all of the files are stored,
being by default the current directory.
#+begin_src emacs-lisp
  (use-package no-littering
    :ensure t)
#+end_src
*** Backup files
Files created with the tilde extension, used to track changes to files, being able to 
recover them on system crash.
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(no-littering-expand-var-file-name "backups/"))))
#+end_src

*** Auto save files
Files created when you haven't saved a file yet.
#+begin_src emacs-lisp
(setq auto-save-list-file-prefix (no-littering-expand-var-file-name "auto-saves/sessions/")
      auto-save-file-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-saves/") t)))
#+end_src
*** Lockfiles and versions
configuration of lockfiles and version control for files,
the intention this modification is the clean workspace directories.
#+begin_src emacs-lisp
(setq
   create-lockfiles nil
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)
#+end_src
** Try
Package that allows to try emacs packages without installing them.
What it really does is installing the files in a temp directory and
removing them later.

#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** Autopair
#+BEGIN_SRC emacs-lisp
(use-package autopair
  :ensure t
  :config (autopair-global-mode))
#+END_SRC

** Modeline
*** Doom-modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :config
  (progn
  (doom-modeline-mode 1)
  (setq doom-modeline-project-detection 'project)
  (setq doom-modeline-window-width-limit fill-column)))
(defvar doom-modeline-icon (display-graphic-p)
  "Whether show `all-the-icons' or not.

  Non-nil to show the icons in mode-line.
  The icons may not be showed correctly in terminal and on Windows."
)
(setq doom-modeline-icon t)
#+END_SRC

*** All-the-icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

** Smart-comment
When at the end of the line, creates a end-line comment.
When at the beginning or middle of the line, comments line.
When pointing at region, comments full region.

#+BEGIN_SRC emacs-lisp
(use-package smart-comment
  :ensure t
  :bind ("M-;" . smart-comment))
#+END_SRC

** Buffers
*** Bufler
Better bufler list, creating projects and groups.
#+BEGIN_SRC emacs-lisp
(use-package bufler
  :ensure t
  :config (defhydra+ hydra:bufler ()
  ("o" #'delete-other-windows "Full screen"))
  :bind (:map bufler-list-mode-map
  ("o" . delete-other-windows)))
#+END_SRC


Function to make bufler buffer full-screen.
#+BEGIN_SRC emacs-lisp
(defun bufler-one-window (&optional force-refresh)
  (interactive "P")
  (bufler-list)
  (delete-other-windows)
)
(global-set-key (kbd "C-x C-b") 'bufler)
#+END_SRC

** Directories

*** Dired
Dired is the "package" that gives us all the functionality
to a dired buffer which in essence is the same as the output
of ls. Adding an especial command for dired-up-directory as 
the default keybinding is ^ which I find difficult to reach.

#+begin_src emacs-lisp
(use-package dired
   :bind (:map dired-mode-map 
   ("b" . dired-up-directory)))
#+end_src


*** Directories first on dired.
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-aBhl  --group-directories-first")
#+END_SRC

*** Backup directory
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("" . "~/.emacs.d/backup")))
#+END_SRC

** Latex
Adding auctex which is a specific package with the intention of
making the latex ide experience.
#+BEGIN_SRC emacs-lisp
  (use-package auctex-latexmk
    :ensure t
    :config
    (auctex-latexmk-setup)
    (setq auctex-latexmk-inherit-TeX-PDF-mode t))

#+END_SRC

Adding reference connection made easier with reftex.
#+BEGIN_SRC emacs-lisp
(use-package reftex
  :ensure t
  :defer t
  :config
  (setq reftex-cite-prompt-optional-args t))
#+END_SRC

Adding autodictionary in order to get completion on the words
that have been miss-typed.
#+BEGIN_SRC emacs-lisp
  (use-package auto-dictionary
    :ensure t
    :init(add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode 1))))
#+END_SRC
  
Adding company backend support to auctex in order to get completions
on the fly.
#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :ensure t
  :init (company-auctex-init))
#+END_SRC

Adding general configuration for tex files and latex-mode better defaults.
#+BEGIN_SRC emacs-lisp
  (use-package tex
  :ensure auctex
  :mode ("\\.tex\\'" . latex-mode)
  :config (progn
	    (setq TeX-source-correlate-mode t)
	    (setq TeX-source-correlate-method 'synctex)
	    (setq TeX-auto-save t)
	    (setq TeX-parse-self t)
	    (setq-default TeX-master nil)
	    (setq reftex-plug-into-AUCTeX t)
	    (pdf-tools-install)
	    (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
		  TeX-source-correlate-start-server t)
	    ;; Update PDF buffers after successful LaTeX runs
	    (add-hook 'TeX-after-compilation-finished-functions
		      #'TeX-revert-document-buffer)
	    (add-hook 'LaTeX-mode-hook
		      (lambda ()
			(reftex-mode t)
			(flyspell-mode t)))
	    ))
#+END_SRC

** Appearence
*** Cursor display
Bar cursor instead of rectangle default.
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

*** Yes/No with y/n
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Splash screen and startup message
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC

*** Line numeration on left side
#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
(put 'erase-buffer 'disabled nil)
#+END_SRC

*** New lines
Adding newline at the end of the file.
#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines t)    
#+END_SRC

*** Sounds
Disabling beep sound.
#+BEGIN_SRC emacs-lisp
(setq visible-bell 1)
#+END_SRC

*** Toolbar
Disabling toolbar.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC

*** Scrollbar
Removing scrollbar.
#+BEGIN_SRC emacs-lisp
(when (fboundp 'set-scroll-bar-mode)
  (set-scroll-bar-mode nil))
(defun qk/disable-scroll-bars (frame)
  (modify-frame-parameters frame
                           '((vertical-scroll-bars . nil)
                             (horizontal-scroll-bars . nil))))
(add-hook 'after-make-frame-functions 'qk/disable-scroll-bars)
#+END_SRC

*** Menubar
Disabling the menubar, prior to tab-mode-line configuration.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
#+END_SRC

*** Tab configuration
#+BEGIN_SRC 
    
#+END_SRC
*** Fonts
#+BEGIN_SRC emacs-lisp
(setq default-frame-alist '((font . "Ubuntu Mono-13")))
#+END_SRC

** Indentation
Indentation to 4 spaces instead of tab.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq indent-line-function 'insert-tab)

#+END_SRC

** Ido
Ido-mode makes better default commands.
# #+BEGIN_SRC emacs-lisp
# (ido-mode 1)
# (setq ido-separator "\n")
# (define-key ido-common-completion-map (kbd "SPC") 'self-insert-command)
# #+END_SRC
** Ivy And Counsel
Both are from the same family, Counsel uses Ivy functionality in
order to provide good completion for emacs commands.
#+BEGIN_SRC emacs-lisp
      (use-package counsel
          :ensure t
          :config 
          (progn 
          (ivy-mode 1)
          (global-set-key (kbd "M-x") 'counsel-M-x)
          (global-set-key "\C-s" 'swiper)
          (global-set-key "\C-r" 'swiper-isearch-backward)
          (global-set-key (kbd "C-x C-f") 'counsel-find-file)
          (global-set-key (kbd "M-y") 'counsel-yank-pop)
          (global-set-key (kbd "<f1> f") 'counsel-describe-function)
          (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
          (global-set-key (kbd "<f1> l") 'counsel-find-library)
          (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
          (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
          (global-set-key (kbd "<f2> j") 'counsel-set-variable)
          (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
          (global-set-key (kbd "C-c v") 'ivy-push-view)
          (global-set-key (kbd "C-c V") 'ivy-pop-view))
          :custom(
          (ivy-use-virtual-buffers t)
          (ivy-count-format "%d/%d ")
          (find-program "fdfind")
          (counsel-file-jump-args (split-string "-L --type f --hidden"))))
      (use-package counsel-projectile
          :ensure t)
      (counsel-projectile-mode 1)

#+END_SRC
*** Prescient
Better sorting mechanism focusing on user data, working better than default
systems using heuristics as time passes. Following lines are added with
the intention of providing prescient magic to other frameworks that I have installed,
like ivy and company.

#+begin_src emacs-lisp
(use-package prescient
    :ensure t
    :config (prescient-persist-mode 1))
(use-package ivy-prescient
    :ensure t
    :config (ivy-prescient-mode 1))
#+end_src

** Hungry-delete
Deleting all the spaces but one when multiple spaces are present.
#+BEGIN_SRC emacs-lisp :tangle no
    (use-package smart-hungry-delete
    :ensure t
    :bind (("<backspace>" . smart-hungry-delete-backward-char)
           ("C-d" . smart-hungry-delete-forward-char)
           ("<DEL>" . smart-hungry-delete-forward-char))
    :defer nil ;; dont defer so we can add our functions to hooks 
    :config (smart-hungry-delete-add-default-hooks))

#+END_SRC

** Markdown
Markdown command, not installed by default.
#+BEGIN_SRC emacs-lisp
(custom-set-variables
  '(markdown-command "/usr/bin/markdown"))
#+END_SRC

** Mark commands
Adding better defaults to the mark commands, as I find cumbersome to remove the
region everytime I want to access the mark functionality.

#+BEGIN_SRC emacs-lisp
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))

(global-set-key (kbd "C-.") 'push-mark-no-activate)
(global-set-key (kbd "C-,") 'jump-to-mark)
(define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+END_SRC

** Window switching
I'm trying ace-window in order to allow faster window switching, when working with
multiple buffers in the same frame. Disabling also the undo command, trying to get
used to C-/
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-x o"))
(global-unset-key (kbd "C-x u"))
(use-package ace-window
   :ensure t
   :config 
   (global-set-key (kbd "M-o") 'ace-window)
   :custom(
   (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
   (aw-background nil)))
#+END_SRC

** Loading config from function
#+BEGIN_SRC emacs-lisp
(defun qk/load-config ()
    "Load my config file linked to config.org."
    (interactive)
    (load-file "~/.emacs.d/init.el"))
#+END_SRC

** Fill column
#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

** Auto indent
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

** pdf tools
   pdf tools so that pages are created on demand instead of preloading the entire file, which
   may freeze emacs. Also adding the hook in order to autorevert the pdf buffer when compiling
    with auctex.
   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :ensure t
       :config (pdf-tools-install)
       (setq-default pdf-view-display-size 'fit-page)
       (setq pdf-annot-activate-created-annotations t)
       (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
       (define-key pdf-view-mode-map (kbd "C-r") 'isearch-backward)
       (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
       (add-hook 'pdf-view-mode-hook (lambda ()
                                       (linum-mode -1))))
   #+END_SRC

** Which key
Which key is the pinnacle of keybinding packages, with
a helpful minibuffer that states the keybindings 
available for a certain prefix you start typing.
#+begin_src emacs-lisp
(use-package which-key
   :ensure t
   :custom
   ((which-key-show-early-on-C-h t)
    (which-key-idle-delay 10000)
    (which-key-idle-secondary-delay 0.05)
    (which-key-popup-type 'minibuffer))
   :config (which-key-mode))
#+end_src

** Ripgrep
Adding ripgrep configuration to be able to 
access the functionality from emacs.
#+begin_src emacs-lisp
(use-package rg
   :ensure t
   :config (rg-enable-default-bindings))
#+end_src

* Terminal
Configuration related to terminal emulators and modes. Recently, 
I started using vterm which is faster than any of the others.

** vterm
#+begin_src emacs-lisp
(use-package vterm
   :ensure t
   :custom (vterm-max-scrollback 10000))
#+end_src

* Org
** Keybindings
Keybindings for org-mode as well as better defaults. Not in use-package format yet.
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-c l") 'org-store-link)
(define-key global-map (kbd "C-c a") 'org-agenda)
(define-key global-map (kbd "C-c c") 'org-capture)
(define-key org-mode-map (kbd "C-,") nil)
#+END_SRC

** Initial configuration
Initial configuration of org-directory and refile.org, with the
intention of all capture created items to go there before correct refiling.
#+BEGIN_SRC emacs-lisp
(setq 
    org-directory "~/Documents/org_files"
    org-default-notes-file (concat org-directory "/org-agenda/refile.org")
    org-agenda-files (list (concat org-directory "/org-agenda"))
    org-archive-location (concat org-directory "/archive/%s_archive::")
    org-refile-targets (quote ((nil :maxlevel . 3)
 	                   (org-agenda-files :maxlevel . 3)))
    org-columns-default-format "%50ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM"
    org-clock-out-remove-zero-time-clocks t
    org-clock-out-when-done t
 )
(defvar org-archive-file-header-format "#+FILETAGS: ARCHIVE\nArchived entries from file %s\n")
#+END_SRC

** Refiling
Refiling setup, using the file name as header. Last line is
so that we ensure that tasks cannot be tagged as completed
before subtasks have been done so.
#+BEGIN_SRC emacs-lisp
(setq
     org-refile-use-outline-path 'file
     org-outline-path-complete-in-steps nil
     org-refile-allow-creating-parent-nodes 'confirm
     org-enforce-todo-dependencies t
 )
#+END_SRC

Adding keywords for easier refiling and capturing. Right side of
the "|" key is used to indicate the keyword designing completion for
a certain state.
#+BEGIN_SRC emacs-lisp
  (setq 
    org-todo-keywords
	    (quote ((sequence "TODO(t)" "|" "DONE(d)")
		    (sequence "PROJECT(p)" "|" "DONE(d)" "CANCELLED(c)")
		    (sequence "WAITING(w)" "|")
		    (sequence "|" "CANCELLED(c)")
            (sequence "|" "OPTIONAL(o)")
		    (sequence "SOMEDAY(s)" "|" "CANCELLED(c)")
		    (sequence "MEETING(m)" "|" "DONE(d)")
		)
	       )
   org-todo-keyword-faces
       '(
           ("PROJECT" . (:foreground "#a87600" :weight bold))
           ("OPTIONAL" . (:foreground "#08a838" :weight bold))
           ("WAITING" . (:foreground "#fe2f92" :weight bold))
           ("CANCELLED" . (:foreground "#999999" :weight bold))
           ("SOMEDAY" . (:foreground "#ab82ff" :weight bold))
           ("MEETING" . (:foreground "#1874cd" :weight bold))
       )
)
#+END_SRC

** Org capture
Capture templates are used with the intention of improving
the workflow of adding several items and refiling.
#+BEGIN_SRC emacs-lisp
(setq
 org-capture-templates
 '(("t" "todo" entry (file org-default-notes-file)
    "* TODO %? :REFILING:\n%a\n" :clock-in t :clock-resume t)
   ("m" "Meeting/Interruption" entry (file org-default-notes-file)
    "* MEETING %? :REFILING:MEETING:\n" :clock-in t :clock-resume t)
   ("i" "Idea" entry (file org-default-notes-file)
    "* %? :REFILING:IDEA:\n" :clock-in t :clock-resume t)
   ("e" "Respond email" entry (file org-default-notes-file)
    "* TODO Write to %? on %? :REFILING:EMAIL: \nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
   ("s" "Someday" entry (file org-default-notes-file)
    "* SOMEDAY %? :REFILING:SOMEDAY:\n" :clock-in t :clock-resume t :empty-lines 1)
   ("p" "Project entry" entry (file org-default-notes-file)
    "* PROJECT %? :REFILING:PROJECT:\n" :clock-in t :clock-resume t :empty-lines 1)
   ("o" "Optional item" entry (file org-default-notes-file)
    "* OPTIONAL %? :REFILING:OPTIONAL:\n" :clock-in t :clock-resume t :empty-lines 1)
   )
 ;; Keep a line between headers
 ;; org-cycle-separator-lines 1
 )
#+END_SRC

** Org agenda
Adding hiding the tags on org agenda.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-hide-tags-regexp (regexp-opt '(
    "REFILING" "MEETING" "IDEA" "EMAIL" "SOMEDAY" "OPTIONAL" "PROJECT")))
#+END_SRC

Removing inherited and REFILING tags in order to use the tags correctly
#+BEGIN_SRC emacs-lisp
(defun qk/org-remove-inherited-tag-strings ()
    "Removes inherited tags from the headline-at-point's tag string.
    Note this does not change the inherited tags for a headline,
    just the tag string."
    (org-set-tags (seq-remove (lambda (tag)
                                (get-text-property 0 'inherited tag))
                              (org-get-tags))))

(defun qk/org-remove-refiling-tag ()
    "Remove the REFILING tag once the item has been refiled."
    (org-toggle-tag "REFILING" 'off))

(defun qk/org-clean-tags ()
  "Visit last refiled headline and remove inherited tags from tag string."
  (save-window-excursion
    (org-refile-goto-last-stored)
    (qk/org-remove-inherited-tag-strings)
    (qk/org-remove-refiling-tag)))

(add-hook 'org-after-refile-insert-hook 'qk/org-clean-tags)
#+END_SRC

Adding series of tags with the intention of tagging the items for better 
organization besides the refile file. Adding automated tasks to a tagged item.
#+BEGIN_SRC emacs-lisp
(setq org-tag-alist '((:startgroup . nil)
			("@work" . ?w)
			("@gym" . ?g)
			("@life" . ?l)
			(:endgroup . nil)
			("literature" . ?n)
			("coding" . ?c)
			("writing" . ?p)
			("emacs" . ?e)
			("misc" . ?m)
			)
	)

(setq
 org-todo-state-tags-triggers
 (quote (
	   ;; Move to cancelled adds the cancelled tag
	   ("CANCELLED" ("CANCELLED" . t))
	   ;; Move to waiting adds the waiting tag
	   ("WAITING" ("WAITING" . t))
	   ;; Move to a done state removes waiting/cancelled
	   (done ("WAITING") ("CANCELLED"))
	   ("DONE" ("WAITING") ("CANCELLED"))
	   ;; Move to todo, removes waiting/cancelled
	   ("TODO" ("WAITING") ("CANCELLED"))
	   )
	  )
 )
#+END_SRC

Adding more beautiful org-agenda view with all-icons and better configuration
of the layout, giving me a lot more information.
#+BEGIN_SRC emacs-lisp
  (setq org-deadline-warning-days 3)
  (setq org-agenda-category-icon-alist
      `(("TODO" (list (all-the-icons-faicon "tasks")) nil nil :ascent center)))
  (setq org-agenda-custom-commands
      '(				; start list
        ("d" "Agenda" ((agenda "" ((org-agenda-overriding-header "Today's Schedule:")
                       (org-agenda-span 'day)
                       (org-agenda-ndays 1)
                       (org-agenda-start-on-weekday nil)
                       (org-agenda-start-day "+0d")
                       (org-agenda-skip-function '(cond ((equal (file-name-nondirectory (buffer-file-name)) "refile.org")
                                         (outline-next-heading) (1- (point)))
                                        (t (org-agenda-skip-entry-if 'todo 'done))
                                        ))
                       (org-agenda-todo-ignore-deadlines nil)))
               ;; Project tickle list.
               (todo "PROJECT" ((org-agenda-overriding-header "Project list:")
                       (org-tags-match-list-sublevels nil)))
               ;; Refiling category set file wide in file.
               (tags "REFILING" ((org-agenda-overriding-header "Tasks to Refile:")
                       (org-tags-match-list-sublevels nil)))
               ;; Tasks upcoming (should be similar to above?)
               (agenda "" ((org-agenda-overriding-header "Upcoming:")
                       (org-agenda-span 7)
                       (org-agenda-start-day "+1d")
                       (org-agenda-start-on-weekday nil)
                       (org-agenda-skip-function '(cond ((equal (file-name-nondirectory (buffer-file-name)) "refile.org")
                                         (outline-next-heading) (1- (point)))
                                        (t (org-agenda-skip-entry-if 'todo 'done))
                                        ))
                       ;; I should set this next one to true, so that deadlines are ignored...?
                       (org-agenda-todo-ignore-deadlines nil)))
               ;; Tasks that are unscheduled
               (todo "TODO" ((org-agenda-overriding-header "Unscheduled Tasks:")
                         (org-tags-match-list-sublevels nil)
                         (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                         ))
               ;; Tasks that are waiting or someday
               (todo "WAITING|SOMEDAY" ((org-agenda-overriding-header "Waiting/Someday Tasks:")
                       (org-tags-match-list-sublevels nil)))
               )
         )
        )				; end list

      ;; If an item has a (near) deadline, and is scheduled, only show the deadline.
      org-agenda-skip-scheduled-if-deadline-is-shown t
      )
#+END_SRC

** Org source blocks
Tabs on org-mode source blocks try to find the language added.
If for some reason the language on the source tag doesn't exist
add 4 spaces.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-tab-first-hook
          (lambda ()
            (when (org-in-src-block-p t)
              (let* ((elt (org-element-at-point))
                     (lang (intern (org-element-property :language elt)))
                     (langs org-babel-load-languages))
                (unless (alist-get lang langs)
                  (indent-to 4))))))
#+END_SRC

Adding custom agenda commands, with the intention of making the refiling and
tagging workflow a bit faster, as C-c C-w might be cumbersome to write in agenda-view.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
          (lambda ()
                  (local-set-key (kbd "r") 'org-agenda-refile)))
#+END_SRC

Creating function which archives all files which contain only done (not necessarily
in a DONE state.) items, with the intention of making org-agenda quicker to proccess.

#+BEGIN_SRC emacs-lisp
(defun qk/archive-done-org-files ()
"Cycles all org files through checking function."
(interactive) 
(save-excursion
(mapc 'check-org-file-finito (directory-files (concat org-directory "/org-agenda") t ".org$"))
))

(defun check-org-file-finito (f)
"Checks TODO keyword items are DONE then archives."
(find-file f)
;; Shows open Todo items whether agenda or todo
(let (
(kwd-re
  (cond (org-not-done-regexp)
    (
     (let ((kwd
        (completing-read "Keyword (or KWD1|KWD2|...): "
                 (mapcar #'list org-todo-keywords-1))))
       (concat "\\("
           (mapconcat 'identity (org-split-string kwd "|") "\\|")
           "\\)\\>")))
    ((<= (prefix-numeric-value) (length org-todo-keywords-1))
     (regexp-quote (nth (1- (prefix-numeric-value))
                org-todo-keywords-1)))
    (t (user-error "Invalid prefix argument: %s")))))
 (if (= (org-occur (concat "^" org-outline-regexp " *" kwd-re )) 0)
 (rename-file-buffer-to-org-archive)
     (kill-buffer (current-buffer))
   )))

(defun rename-file-buffer-to-org-archive ()
"Renames current buffer and file it's visiting."
(let ((name (buffer-name))
    (filename (buffer-file-name))
)
(if (not (and filename (file-exists-p filename)))
    (error "Buffer '%s' is not visiting a file!" name)
  (let ((new-name (concat (file-name-sans-extension filename) ".org_archive")))
    (if (get-buffer new-name)
        (error "A buffer named '%s' already exists!" new-name)
      (rename-file filename new-name 1)
      (rename-buffer new-name)
      (set-visited-file-name new-name)
      (set-buffer-modified-p nil)
  (kill-buffer (current-buffer))
  (message "File '%s' successfully archived as '%s'."
               name (file-name-nondirectory new-name)))))))
#+END_SRC

** Org-roam
I use the Zettelkasten (slip-box) method for taking and recalling notes and
information. To be able to do so, I started with my own workflow, adding
org-mode links to the different notes, and has been working for me for 
close to a month. As a way of improving this workflow, I decided to give
org-roam a chance.

#+BEGIN_SRC emacs-lisp
(use-package org-roam
      :ensure t
      :hook
      (after-init . org-roam-mode)
      :custom
      (org-roam-directory "~/Documents/org_files/slip-box/")
      :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n g" . org-roam-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))
              (("C-c n I" . org-roam-insert-immediate))))
#+END_SRC

** Org-pomodoro
Adding pomodoro implementation with the intention of keeping everything
I use inside of emacs, according to the OS emacs mindset.
#+begin_src emacs-lisp
(use-package org-pomodoro
    :ensure t)
#+end_src

* Version control
Obviously Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status)
  :config (setq magit-refresh-status-buffer nil))
#+END_SRC
** Magit forge
Magit with the integration of Github Issues.
#+BEGIN_SRC emacs-lisp
(use-package forge
  :ensure t
  :after magit)

;; Setting up forge token.
(setq auth-sources '("~/.authinfo"))
#+END_SRC

* Project management
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
;; Working on ubuntu, if you are not, change fdfind to fd.
  :custom (projectile-generic-command "fdfind . -0 --type f --color=never")
  :config(progn 
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (setq projectile-project-search-path '("~/Documents/"))
  (projectile-global-mode)
  ))
(with-eval-after-load 'projectile
  (add-to-list 'projectile-project-root-files-bottom-up "pubspec.yaml")
  (add-to-list 'projectile-project-root-files-bottom-up "BUILD"))
#+END_SRC

* Snippets
** Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config (yas-global-mode))
#+END_SRC

** Better yasnippets for modes.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t)
#+END_SRC

* Programming
** Company
Company is used for better completion on the fly.
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config (progn 
  (global-company-mode 1)
  (setq company-show-numbers t)
  (setq company-dabbrev-downcase 0)
  (setq company-idle-delay 0)
  ))
#+END_SRC

Adding completion on tab.
#+BEGIN_SRC emacs-lisp
(defun tab-indent-or-complete ()
  (interactive)
  (if (minibufferp)
      (minibuffer-complete)
    (if (or (not yas-minor-mode)
            (null (do-yas-expand)))
        (if (check-expansion)
            (company-complete-common)
          (indent-for-tab-command)))))
(global-set-key [backtab] 'tab-indent-or-complete)
#+END_SRC

Adding prescient sorting and filtering mechanism with the intention
of enabling a better candidate mechanism.
#+begin_src emacs-lisp
(use-package company-prescient
    :ensure t
    :config (company-prescient-mode 1))
#+end_src


** Web programming
*** CSS
Rainbow-mode: CSS colors on the sideline.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :hook (rainbow-mode . css-mode-hook))
#+END_SRC

*** Emmet-mode: NOT WORKING ATM.  
Better completion for html tags, very good documentation.
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :hook ((sgml-mode-hook . emmet-mode)
  (css-mode-hook . emmet-mode)))
#+END_SRC

*** Web-mode: NOT WORKING ATM.
Web-mode for html and css programming.
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html?\\'" . web-mode)
  :hook (prog-mode . hs-minor-mode))
#+END_SRC

** Server side functionality (LSP)
Lsp-mode for server completion.
*** Flycheck
Sintax checking on the fly.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
    :ensure t)
#+END_SRC

*** lsp-mode
#+BEGIN_SRC emacs-lisp
(setq lsp-keymap-prefix "C-l")
(use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :config (setq lsp-enable-links nil)
    :hook (python-mode . lsp-deferred)
    :custom ((gc-cons-threshold 100000000)
             (read-process-output-max (* 1024 1024))
             (lsp-completion-provider :capf)
             (lsp-idle-delay 0.500)
             (lsp-enable-file-watchers nil)
             (lsp-signature-auto-activate nil)
             (lsp-headerline-breadcrumb-enable nil)
             ))
#+END_SRC

**** Dap-mode
Server side debugging protocol, seemed to be installed with lsp-dart,
I'm adding the package here just to make sure, as I couldn't load
lsp-dart or lsp-java because dap-mode wasn't available.
#+begin_src emacs-lisp
(use-package dap-mode
    :ensure t)
#+end_src
**** lsp-ui
Better ui for lsp-mode, adding el-doc.
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :requires (flycheck)
  :ensure t
  :commands lsp-ui-mode
  :config (setq lsp-ui-sideline-show-code-actions nil))
#+END_SRC

**** lsp-ivy
Buffer cycling and find-files quicker. Close to helm.
#+BEGIN_SRC emacs-lisp
(use-package lsp-ivy
  :ensure t  
  :commands lsp-ivy-workspace-symbol)
#+END_SRC

**** lsp-treemacs
#+BEGIN_SRC emacs-lisp
(use-package lsp-treemacs
  :ensure t
  :commands lsp-treemacs-errors-list)
(use-package treemacs
  :defer t
  :bind (:map global-map
              ("<f8>" . treemacs)))
#+END_SRC

**** C++/C programming.
Always works on C++, sometimes wrong on C programming.
#+BEGIN_SRC emacs-lisp
(use-package ccls
  :ensure t
  :config (progn
  (setq ccls-executable "ccls")
  (setq lsp-prefer-flymake nil)
  (setq-default flycheck-disabled-checkers '(c/c++-clang c/c++-cppcheck c/c++-gcc)))
  :hook ((c-mode c++-mode objc-mode) .
         (lambda () (require 'ccls) (lsp-deferred))))
#+END_SRC

**** Dart/Flutter programming
#+BEGIN_SRC emacs-lisp
(use-package lsp-dart 
  :ensure t
  :hook (dart-mode . lsp))
(setq dart-sdk-path "~/snap/flutter/common/flutter/bin/cache/dart-sdk")
(setq lsp-dart-sdk-dir "~/snap/flutter/common/flutter/bin/cache/dart-sdk")
(setq lsp-dart-flutter-sdk-dir "~/snap/flutter/common/flutter")
(setq lsp-dart-main-code-lens nil)
(setq dart-format-on-save t)
#+END_SRC

***** Hover
Using desktop windows to emulate a Flutter process.
#+BEGIN_SRC emacs-lisp
(use-package hover
  :ensure t
  :after dart-mode
    :init 
    (setq hover-hot-reload-on-save t
          hover-clear-buffer-on-hot-restart t)
  :bind (:map dart-mode-map ("C-M-z" . hover-run-or-hot-reload)))
#+END_SRC

**** Java Programming
Works with the eclipse server, not really sure if it is what I'm looking for.
#+BEGIN_SRC emacs-lisp
(use-package lsp-java
    :ensure t
    :hook (java-mode . lsp-deferred))
#+END_SRC

**** Python programming
I'm using pyls.
* Extra
** Speed-test
Practicing typing speed in emacs.
#+BEGIN_SRC emacs-lisp
(use-package speed-type
    :ensure t)

(defun qk/type-test ()
   (interactive)
   (browse-url-firefox "https://monkeytype.com/"))
#+END_SRC

** Snow for Christmas
Package which uses ascii symbols in order to create a
snowy environment in emacs!

#+BEGIN_SRC emacs-lisp
(use-package snow
    :ensure t)
#+END_SRC

