* Themes
** Subatomic theme.
#+BEGIN_SRC emacs-lisp
(use-package subatomic-theme
  :ensure t)
#+END_SRC

** Gruvbox theme.
#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :ensure t
  :config (load-theme 'gruvbox-dark-soft t))
#+END_SRC

** Sublime-themes.
#+BEGIN_SRC emacs-lisp
(use-package sublime-themes
  :ensure t)
#+END_SRC

** Monokai-theme
#+BEGIN_SRC emacs-lisp
(use-package monokai-theme
  :ensure t)
#+END_SRC

* Better defaults
** Hungry-delete.
Deleting all the spaces but one when multiple spaces are present.
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :ensure t)

#+END_SRC

** Autopair
#+BEGIN_SRC emacs-lisp
(use-package autopair
  :ensure t
  :config (autopair-global-mode))
#+END_SRC

** Modeline
*** Doom-modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :config
  (progn
  (doom-modeline-mode 1)
  (setq doom-modeline-project-detection 'project)
  (setq doom-modeline-window-width-limit fill-column)))
#+END_SRC

*** All-the-icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

** Smart-comment
When at the end of the line, creates a end-line comment.
When at the beginning or middle of the line, comments line.
When pointing at region, comments full region.

#+BEGIN_SRC emacs-lisp
(use-package smart-comment
  :ensure t
  :bind ("M-;" . smart-comment))
#+END_SRC

** Buffers
*** Bufler
Better bufler list, creating projects and groups.
#+BEGIN_SRC emacs-lisp
(use-package bufler
  :ensure t
  :config (defhydra+ hydra:bufler ()
  ("o" #'delete-other-windows "Full screen"))
  :bind (:map bufler-list-mode-map
  ("o" . delete-other-windows)))
#+END_SRC


Function to make bufler buffer full-screen.
#+BEGIN_SRC emacs-lisp
(defun bufler-one-window (&optional force-refresh)
  (interactive "P")
  (bufler-list)
  (delete-other-windows)
)
(global-set-key (kbd "C-x C-b") 'bufler)
#+END_SRC

** Directories
*** Directories first on dired.
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-aBhl  --group-directories-first")
#+END_SRC

*** Backup directory
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("" . "~/.emacs.d/backup")))
#+END_SRC

** Latex
PDF mode on latex by default.
#+BEGIN_SRC emacs-lisp
(setq TeX-PDF-mode t)
#+END_SRC

** Appearence
*** Cursor display
Bar cursor instead of rectangle default.
#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

*** Yes/No with y/n
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Splash screen and startup message
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC

*** Line numeration on left side
#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
(put 'erase-buffer 'disabled nil)
#+END_SRC

*** New lines
Adding newline at the end of the file.
#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines t)    
#+END_SRC

*** Sounds
Disabling beep sound.
#+BEGIN_SRC emacs-lisp
(setq visible-bell 1)
#+END_SRC

*** Toolbar
Disabling toolbar.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC

*** Scrollbar
Removing scrollbar.
#+BEGIN_SRC emacs-lisp
(when (fboundp 'set-scroll-bar-mode)
  (set-scroll-bar-mode nil))
#+END_SRC

*** Fonts
#+BEGIN_SRC emacs-lisp
(setq default-frame-alist '((font . "Ubuntu Mono-13")))
#+END_SRC

** Indentation
Indentation to 4 spaces instead of tab.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq indent-line-function 'insert-tab)

#+END_SRC

** Ido
Ido-mode makes better default commands.
# #+BEGIN_SRC emacs-lisp
# (ido-mode 1)
# (setq ido-separator "\n")
# (define-key ido-common-completion-map (kbd "SPC") 'self-insert-command)
# #+END_SRC
** Ivy And Counsel
Both are from the same family, Counsel uses Ivy functionality in
order to provide good completion for emacs commands.
#+BEGIN_SRC emacs-lisp
(use-package counsel
    :ensure t
    :config 
    (progn 
    (ivy-mode 1)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key "\C-s" 'swiper)
    (global-set-key "\C-r" 'swiper-isearch-backward)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "M-y") 'counsel-yank-pop)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-find-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "<f2> j") 'counsel-set-variable)
    (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
    (global-set-key (kbd "C-c v") 'ivy-push-view)
    (global-set-key (kbd "C-c V") 'ivy-pop-view))
    :custom(
    (ivy-use-virtual-buffers t)
    (ivy-count-format "%d/%d ")))

(use-package counsel-projectile
    :ensure t)
(counsel-projectile-mode 1)

#+END_SRC

** Markdown
Markdown command, not installed by default.
#+BEGIN_SRC emacs-lisp
(custom-set-variables
  '(markdown-command "/usr/bin/markdown"))
#+END_SRC

** Mark commands
Adding better defaults to the mark commands, as I find cumbersome to remove the
region everytime I want to access the mark functionality.

#+BEGIN_SRC emacs-lisp
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))

(global-set-key (kbd "C-.") 'push-mark-no-activate)
(global-set-key (kbd "C-,") 'jump-to-mark)
(define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+END_SRC

** Window switching
I'm trying ace-window in order to allow faster window switching, when working with
multiple buffers in the same frame.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
   :ensure t
   :config (global-set-key (kbd "C-x o") 'ace-window)
   :custom(
   (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
   (aw-background nil)))
#+END_SRC

* Org
Keybindings for org-mode as well as better defaults. Not in use-package format yet.
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-c l") 'org-store-link)
  (define-key global-map (kbd "C-c a") 'org-agenda)
  (define-key org-mode-map (kbd "C-,") nil)
  (setq org-log-done t)
  (setq org-agenda-files (list "~/Documents/org_files/org-agenda"))
  (setq org-todo-keywords
        '((sequence "TODO" "WAITING" "|" "DONE" "OPTIONAL" "DELEGATED")))
  ;; (setq org-agenda-window-setup 'only-window)
#+END_SRC

** Org-roam
I use the Zettelkasten (slip-box) method for taking and recalling notes and
information. To be able to do so, I started with my own workflow, adding
org-mode links to the different notes, and has been working for me for 
close to a month. As a way of improving this workflow, I decided to give
org-roam a chance.

#+BEGIN_SRC emacs-lisp
(use-package org-roam
      :ensure t
      :hook
      (after-init . org-roam-mode)
      :custom
      (org-roam-directory "~/Documents/org_files/slip-box/")
      :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n g" . org-roam-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))
              (("C-c n I" . org-roam-insert-immediate))))
#+END_SRC

* Version control
Obviously Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status)
  :config (setq magit-refresh-status-buffer nil))
#+END_SRC

* Project management
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config(progn 
  (define-key projectile-mode-map (kbd "C-c") 'projectile-command-map)
  (setq projectile-project-search-path '("~/Documents/"))
  (define-key projectile-mode-map (kbd "C-c l") nil)
  (define-key projectile-mode-map (kbd "C-c a") nil)
  (projectile-global-mode)
  ))
#+END_SRC

* Snippets
** Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config (yas-global-mode))
#+END_SRC

** Better yasnippets for modes.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t)
#+END_SRC

* Programming
** Company
Company is used for better completion on the fly.
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config (progn 
  (global-company-mode 1)
  (setq company-show-numbers t)
  (setq company-dabbrev-downcase 0)
  (setq company-idle-delay 0)
  ))
#+END_SRC

Adding completion on tab.
#+BEGIN_SRC emacs-lisp
(defun tab-indent-or-complete ()
  (interactive)
  (if (minibufferp)
      (minibuffer-complete)
    (if (or (not yas-minor-mode)
            (null (do-yas-expand)))
        (if (check-expansion)
            (company-complete-common)
          (indent-for-tab-command)))))
(global-set-key [backtab] 'tab-indent-or-complete)
#+END_SRC

** Web programming
*** CSS
Rainbow-mode: CSS colors on the sideline.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :hook (rainbow-mode . css-mode-hook))
#+END_SRC

*** Emmet-mode: NOT WORKING ATM.  
Better completion for html tags, very good documentation.
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :hook ((sgml-mode-hook . emmet-mode)
  (css-mode-hook . emmet-mode)))
#+END_SRC

*** Web-mode: NOT WORKING ATM.
Web-mode for html and css programming.
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html?\\'" . web-mode)
  :hook (prog-mode . hs-minor-mode))
#+END_SRC

** Server side functionality (LSP)
Lsp-mode for server completion.
*** Flycheck
Sintax checking on the fly.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
    :ensure t)
#+END_SRC

*** lsp-mode
#+BEGIN_SRC emacs-lisp
(setq lsp-keymap-prefix "C-l")
(use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :config (setq lsp-enable-links nil)
    :hook (python-mode . lsp-deferred)
    :custom ((gc-cons-threshold 100000000)
             (read-process-output-max (* 1024 1024))
             (lsp-completion-provider :capf)
             (lsp-idle-delay 0.500)
             (lsp-enable-file-watchers nil)
             (lsp-signature-auto-activate t)
             (lsp-signature-doc-lines 1)
             ))
#+END_SRC

**** Dap-mode
Server side debugging protocol, seemed to be installed with lsp-dart,
I'm adding the package here just to make sure, as I couldn't load
lsp-dart or lsp-java because dap-mode wasn't available.
#+begin_src emacs-lisp
(use-package dap-mode
    :ensure t)
#+end_src
**** lsp-ui
Better ui for lsp-mode, adding el-doc.
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :requires (flycheck)
  :ensure t
  :commands lsp-ui-mode
  :config (setq lsp-ui-sideline-show-code-actions nil))
#+END_SRC

**** lsp-ivy
Buffer cycling and find-files quicker. Close to helm.
#+BEGIN_SRC emacs-lisp
(use-package lsp-ivy
  :ensure t  
  :commands lsp-ivy-workspace-symbol)
#+END_SRC

**** lsp-treemacs
#+BEGIN_SRC emacs-lisp
(use-package lsp-treemacs
  :ensure t
  :commands lsp-treemacs-errors-list)
(use-package treemacs
  :defer t
  :bind (:map global-map
              ("<f8>" . treemacs)))
#+END_SRC

**** C++/C programming.
Always works on C++, sometimes wrong on C programming.
#+BEGIN_SRC emacs-lisp
(use-package ccls
  :ensure t
  :config (progn
  (setq ccls-executable "ccls")
  (setq lsp-prefer-flymake nil)
  (setq-default flycheck-disabled-checkers '(c/c++-clang c/c++-cppcheck c/c++-gcc)))
  :hook ((c-mode c++-mode objc-mode) .
         (lambda () (require 'ccls) (lsp-deferred))))
#+END_SRC

**** Dart/Flutter programming
#+BEGIN_SRC emacs-lisp
(use-package lsp-dart 
  :ensure t
  :hook (dart-mode . lsp))
(setq lsp-dart-sdk-dir "~/snap/flutter/common/flutter/bin/cache/dart-sdk")
(setq lsp-dart-flutter-sdk-dir "~/snap/flutter/common/flutter")
(setq lsp-dart-main-code-lens nil)
(setq dart-format-on-save t)
#+END_SRC

***** Hover
Using desktop windows to emulate a Flutter process.
#+BEGIN_SRC emacs-lisp
(use-package hover
  :ensure t
  :after dart-mode
  :custom ((hover-command-path "~/go/bin/hover")
    (hover-flutter-sdk-path "~/snap/flutter/common/flutter"))
  :bind (:map dart-mode-map ("C-M-z" . hover-run-or-hot-reload)))
#+END_SRC

**** Java Programming
Works with the eclipse server, not really sure if it is what I'm looking for.
#+BEGIN_SRC emacs-lisp
(use-package lsp-java
    :ensure t
    :hook (java-mode . lsp-deferred))
#+END_SRC

**** Python programming
I'm using pyls.
